when API.request("create_user", username, email, password) -> request_id
sync User.signup(username, email, password) -> user_id
     User.get(user_id) -> user
     Profile.create(user_id) -> profile
     JWT.make(user_id) -> token
     Map.mergeAs("user", user, profile, token) -> response
     API.respond(request_id, response)

when API.request("login_user", email, password) -> request_id
sync User.login(email, password) -> user_id
     User.get(user_id) -> user
     Profile.get(user_id) -> profile
     JWT.make(user_id) -> token
     Map.mergeAs("user", user, profile, token) -> response
     API.respond(request_id, response)

when API.request("get_user", token) -> request_id
sync JWT.verify(token) -> user_id
     User.get(user_id) -> user
     Profile.get(user_id) -> profile
     Map.mergeAs("user", user, profile, token) -> response
     API.respond(request_id, response)

when API.request("update_user", token, username, email, password, bio, image) -> request_id
sync JWT.verify(token) -> user_id
     User.update(user_id, username, email, password) -> user
     Profile.update(user_id, bio, image) -> profile
     Map.mergeAs("user", user, profile, token) -> response
     API.respond(request_id, response)

when API.request("get_profile", target) -> request_id
sync User.usernameToId(target) -> target_id
     User.get(target_id) -> target_info
     Profile.get(target_id) -> profile
     Follows.doesFollow("", target_id) -> follows
     Map.mergeAs("profile", profile, target_info, follows) -> response
     API.respond(request_id, response)

when API.request("get_profile", token, target) -> request_id
sync JWT.verify(token) -> user_id
     User.usernameToId(target) -> target_id
     User.get(target_id) -> target_info
     Profile.get(target_id) -> profile
     Follows.doesFollow(user_id, target_id) -> follows
     Map.mergeAs("profile", profile, target_info, follows) -> response
     API.respond(request_id, response)

when API.request("follow_user", token, target) -> request_id
sync JWT.verify(token) -> user_id
     User.usernameToId(target) -> target_id
     Follows.create(user_id, target_id)
     Profile.get(target_id) -> profile
     User.get(target_id) -> target_info
     Follows.doesFollow(user_id, target_id) -> follows
     Map.mergeAs("profile", profile, target_info, follows) -> response
     API.respond(request_id, response)

when API.request("unfollow_user", token, target) -> request_id
sync JWT.verify(token) -> user_id
     User.usernameToId(target) -> target_id
     Follows.delete(user_id, target_id)
     Profile.get(target_id) -> profile
     User.get(target_id) -> target_info
     Follows.doesFollow(user_id, target_id) -> follows
     Map.mergeAs("profile", profile, target_info, follows) -> response
     API.respond(request_id, response)

when API.request("list_articles", tag, author, favorited, limit, offset) -> request_id
sync User.usernameToId(author) -> author_id
     User.usernameToId(favorited) -> favorited_id
     Article.allByAuthor(author_id) -> by_author
     Favorites.byFavorited(by_author, "", favorited_id) -> by_favorited
     Tag.byTag(by_favorited, tag) -> by_tag
     Map.getKeys(by_tag, "author") -> author_ids
     User.addMany(author_ids) -> added_user_info
     Profile.addMany(added_user_info) -> added_profile_info
     Follows.addMany(added_profile_info, "") -> added_follow_info
     Map.updateKeys(added_follow_info, "author") -> author_profiles
     Map.mergeValues(by_tag, author_profiles) -> result
     Map.paginate(result, limit, offset) -> paginated
     Map.countAs("articlesCount", paginated) -> article_count
     Map.collectAs("articles", paginated) -> collected
     Map.merge(collected, article_count) -> response
     API.respond(request_id, response)

when API.request("list_articles", token, tag, author, favorited, limit, offset) -> request_id
sync JWT.verify(token) -> user_id
     User.usernameToId(author) -> author_id
     User.usernameToId(favorited) -> favorited_id
     Article.allByAuthor(author_id) -> by_author
     Favorites.byFavorited(by_author, user_id, favorited_id) -> by_favorited
     Tag.byTag(by_favorited, tag) -> by_tag
     Map.getKeys(by_tag, "author") -> author_ids
     User.addMany(author_ids) -> added_user_info
     Profile.addMany(added_user_info) -> added_profile_info
     Follows.addMany(added_profile_info, user_id) -> added_follow_info
     Map.updateKeys(added_follow_info, "author") -> author_profiles
     Map.mergeValues(by_tag, author_profiles) -> result
     Map.paginate(result, limit, offset) -> paginated
     Map.countAs("articlesCount", paginated) -> article_count
     Map.collectAs("articles", paginated) -> collected
     Map.merge(collected, article_count) -> response
     API.respond(request_id, response)

when API.request("get_article", slug) -> request_id
sync Article.getIdBySlug(slug) -> article_id
     Article.get(article_id) -> article
     Article.getAuthorId(article_id) -> author_id
     User.get(author_id) -> author
     Follows.doesFollow("", author_id) -> following
     Map.mergeAs("author", author, following) -> author_info
     Favorites.isFavorited("", article_id) -> favorited
     Favorites.favoritesCount(article_id) -> favoritesCount
     Tag.get(article_id) -> tags
     Map.mergeAs("article", article, tags, author_info, favorited, favoritesCount) -> response
     API.respond(request_id, response)

when API.request("create_article", token, title, description, body, tagList) -> request_id
sync JWT.verify(token) -> user_id
     Article.create(title, description, body, user_id) -> article_id
     Article.get(article_id) -> article
     Tag.create(article_id, tagList) -> tags
     User.get(user_id) -> user
     Profile.get(user_id) -> profile
     Favorites.isFavorited(user_id, article_id) -> favorited
     Favorites.favoritesCount(article_id) -> favoritesCount
     Map.mergeAs("author", user, profile) -> author
     Map.mergeAs("article", article, tags, author, favorited, favoritesCount) -> response
     API.respond(request_id, response)

when API.request("get_tags") -> request_id
sync Tag.all() -> response
     API.respond(request_id, response)

when Sync.run(action, arguments)
     Concept.lookup(action) -> concept
     State.get(concept) -> before
sync Sync.invoke(action, before, arguments) -> after, returns
     State.compare(before, after) -> diff
     State.update(concept, diff)

when Sync.run(action, arguments)
     Operational.lookup(action) -> operation
sync Sync.execute(operation, arguments) -> returns

when State.update(concept, diff)
     MongoDB.getCollection(concept) -> collection
sync MongoDB.update(collection, diff)